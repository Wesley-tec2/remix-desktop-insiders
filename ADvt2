// SPDX-License-Identifier:GPL-3.0 
pragma solidity >=0.8.24;

/// @title            Decompiled Contract
/// @author           Jonathan Becker <jonathan@jbecker.dev>
/// @custom:version   heimdall-rs v0.8.4
///
/// @notice           This contract was decompiled using the heimdall-rs decompiler.
///                     It was generated directly by tracing the EVM opcodes from this contract.
///                     As a result, it may not compile or even be valid solidity code.
///                     Despite this, it should be obvious what each function does. Overall
///                     logic should have been preserved throughout decompiling.
///
/// @custom:github    You can find the open-source decompiler here:
///                       https://heimdall.rs

contract DecompiledContract {
    uint256 public constant unresolved_2e0f2625 = 1000000000000000000;
    uint256 public constant unresolved_313ce567 = 18;
    
    uint256 public unresolved_378dc3dc;
    address public unresolved_893d20e8;
    uint256 public unresolved_a071dcf4;
    bytes32 store_b;
    bool public unresolved_e5ed3d4e;
    address public unresolved_4dacf3f5;
    address public unresolved_7dfcbe34;
    mapping(bytes32 => bytes32) storage_map_c;
    mapping(bytes32 => bytes32) storage_map_d;
    uint256 public unresolved_18160ddd;
    bytes32 store_l;
    mapping(bytes32 => bytes32) storage_map_k;
    
    event Event_8c5be1e5();
    error CustomError_00000000();
    event Event_8be0079c();
    
    /// @custom:selector    0x06fdde03
    /// @custom:signature   Unresolved_06fdde03() public view returns (string memory)
    function Unresolved_06fdde03() public view returns (string memory) {
        if (store_b) {
            if (store_b - ((store_b >> 0x01) < 0x20)) {
                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
                var_b = 0x22;
                uint256 var_c = var_c + (0x20 + (((0x1f + (store_b >> 0x01)) / 0x20) * 0x20));
                bytes32 var_d = store_b >> 0x01;
                if (store_b) {
                    if (store_b - ((store_b >> 0x01) < 0x20)) {
                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
                        var_b = 0x22;
                        if (!store_b >> 0x01) {
                            if (0x1f < (store_b >> 0x01)) {
                                var_a = 0x03;
                                var_e = storage_map_c[var_a];
                                if ((0x20 + var_c) + (store_b >> 0x01) > (0x20 + (0x20 + var_c))) {
                                    var_e = 0x20;
                                    uint256 var_f = var_c.length;
                                    uint256 var_g = 0;
                                    return abi.encodePacked(0x20, var_c.length);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// @custom:selector    0x4838d165
    /// @custom:signature   Unresolved_4838d165(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_4838d165(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        var_a = 0x0e;
        address var_b = arg0;
        address var_c = !(!bytes1(storage_map_d[var_b]));
        return !(!bytes1(storage_map_d[var_b]));
    }
    
    /// @custom:selector    0x23b872dd
    /// @custom:signature   Unresolved_23b872dd(address arg0) public pure
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_23b872dd(address arg0) public pure {
        require(arg0 == (address(arg0)));
    }
    
    /// @custom:selector    0xee3b0d62
    /// @custom:signature   Unresolved_ee3b0d62(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_ee3b0d62(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        var_a = 0x07;
        address var_b = arg0;
        address var_c = !(!bytes1(storage_map_d[var_b]));
        return !(!bytes1(storage_map_d[var_b]));
    }
    
    /// @custom:selector    0x298bb0f9
    /// @custom:signature   Unresolved_298bb0f9(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_298bb0f9(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        address var_a = address(arg0);
        var_b = 0x09;
        address var_c = !(!bytes1(storage_map_c[var_a]));
        return !(!bytes1(storage_map_c[var_a]));
    }
    
    /// @custom:selector    0x07184e17
    /// @custom:signature   Unresolved_07184e17(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_07184e17(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        address var_a = address(arg0);
        var_b = 0x07;
        address var_c = !(!bytes1(storage_map_c[var_a]));
        return !(!bytes1(storage_map_c[var_a]));
    }
    
    /// @custom:selector    0x095ea7b3
    /// @custom:signature   Unresolved_095ea7b3(address arg0, uint256 arg1) public payable returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_095ea7b3(address arg0, uint256 arg1) public payable returns (bool) {
        require(arg0 == (address(arg0)));
        require(address(msg.sender), CustomError_94280d62());
        require(address(arg0), CustomError_94280d62());
        address var_a = address(msg.sender);
        var_b = 0x01;
        var_a = address(arg0);
        address var_b = keccak256(var_a);
        storage_map_c[var_a] = arg1;
        require(!0x01, CustomError_94280d62());
        var_c = 0x01;
        return 0x01;
        uint256 var_c = arg1;
        emit Event_8c5be1e5(address(msg.sender), address(arg0), arg1);
        var_c = 0x01;
        return 0x01;
        var_c = 0x94280d6200000000000000000000000000000000000000000000000000000000;
        uint256 var_d = 0;
        var_c = 0xe602df0500000000000000000000000000000000000000000000000000000000;
        var_d = 0;
    }
    
    /// @custom:selector    0xf2fde38b
    /// @custom:signature   Unresolved_f2fde38b(address arg0) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_f2fde38b(address arg0) public payable {
        require(arg0 == (address(arg0)));
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        require(address(arg0), CustomError_1e4fbdf7());
        unresolved_893d20e8 = (uint96(unresolved_893d20e8)) | (0x0100 * (address(arg0)));
        emit Event_8be0079c(address(unresolved_893d20e8 / 0x0100), address(arg0));
        var_a = 0x1e4fbdf700000000000000000000000000000000000000000000000000000000;
        var_b = 0;
    }
    
    /// @custom:selector    0xa9059cbb
    /// @custom:signature   Unresolved_a9059cbb(address arg0, uint256 arg1) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_a9059cbb(address arg0, uint256 arg1) public payable {
        require(arg0 == (address(arg0)));
        require(address(msg.sender), CustomError_d93c0665());
        require(address(arg0), CustomError_d93c0665());
        require(!(bytes1(unresolved_893d20e8)), CustomError_d93c0665());
        var_a = 0xd93c066500000000000000000000000000000000000000000000000000000000;
        address var_b = address(msg.sender);
        var_c = 0x07;
        require(bytes1(storage_map_d[var_b]));
        var_b = address(arg0);
        var_c = 0x09;
        require(bytes1(storage_map_d[var_b]));
        require(bytes1(storage_map_d[var_b]));
        var_a = 0xa571c0d100000000000000000000000000000000000000000000000000000000;
        address var_d = address(arg0);
        require(address(unresolved_7dfcbe34).code.length);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: 0 }(abi.encode(0xa571c0d100000000000000000000000000000000000000000000000000000000));
        var_a = 0x8450f8a300000000000000000000000000000000000000000000000000000000;
        var_d = address(arg0);
        uint256 var_e = arg1;
        (bool success, bytes memory ret0) = address(unresolved_4dacf3f5).call{ gas: gasleft(), value: 0 }(abi.encode(0x8450f8a300000000000000000000000000000000000000000000000000000000));
        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));
        require(!(((var_f + ret0.length) - var_f) < 0x20), CustomError_379d5801());
        require(var_f.length == var_f.length, CustomError_379d5801());
        require(!var_f.length, CustomError_379d5801());
        var_g = 0x379d580100000000000000000000000000000000000000000000000000000000;
        var_a = 0xd406b88a00000000000000000000000000000000000000000000000000000000;
        var_d = address(msg.sender);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: 0 }(abi.encode(0xd406b88a00000000000000000000000000000000000000000000000000000000, 0x379d580100000000000000000000000000000000000000000000000000000000));
        var_a = 0xec442f0500000000000000000000000000000000000000000000000000000000;
        var_d = 0;
        var_a = 0x96c6fd1e00000000000000000000000000000000000000000000000000000000;
        var_d = 0;
    }
    
    /// @custom:selector    0x42966c68
    /// @custom:signature   Unresolved_42966c68(uint256 arg0) public payable
    /// @param              arg0 ["uint256", "bytes32", "int256"]
    function Unresolved_42966c68(uint256 arg0) public payable {
        require(address(msg.sender), CustomError_d93c0665());
        require(!(bytes1(unresolved_893d20e8)), CustomError_d93c0665());
        var_a = 0xd93c066500000000000000000000000000000000000000000000000000000000;
        address var_b = address(msg.sender);
        var_c = 0x07;
        require(bytes1(storage_map_d[var_b]));
        var_b = 0;
        var_c = 0x09;
        require(bytes1(storage_map_d[var_b]));
        require(bytes1(storage_map_d[var_b]));
        var_a = 0xa571c0d100000000000000000000000000000000000000000000000000000000;
        uint256 var_d = 0;
        require(address(unresolved_7dfcbe34).code.length);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: var_b }(abi.encode(0xa571c0d100000000000000000000000000000000000000000000000000000000));
        var_a = 0x8450f8a300000000000000000000000000000000000000000000000000000000;
        var_d = 0;
        uint256 var_e = arg0;
        (bool success, bytes memory ret0) = address(unresolved_4dacf3f5).call{ gas: gasleft(), value: var_b }(abi.encode(0x8450f8a300000000000000000000000000000000000000000000000000000000));
        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));
        require(!(((var_f + ret0.length) - var_f) < 0x20), CustomError_379d5801());
        require(var_f.length == var_f.length, CustomError_379d5801());
        require(!var_f.length, CustomError_379d5801());
        var_g = 0x379d580100000000000000000000000000000000000000000000000000000000;
        var_a = 0xd406b88a00000000000000000000000000000000000000000000000000000000;
        var_d = address(msg.sender);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: var_b }(abi.encode(0xd406b88a00000000000000000000000000000000000000000000000000000000, 0x379d580100000000000000000000000000000000000000000000000000000000));
        var_a = 0x96c6fd1e00000000000000000000000000000000000000000000000000000000;
        var_d = 0;
    }
    
    /// @custom:selector    0x79cc6790
    /// @custom:signature   Unresolved_79cc6790(address arg0, uint256 arg1) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_79cc6790(address arg0, uint256 arg1) public payable {
        require(arg0 == (address(arg0)));
        address var_a = address(arg0);
        var_b = 0x01;
        var_a = address(msg.sender);
        address var_b = keccak256(var_a);
        require(storage_map_c[var_a] == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, CustomError_d93c0665());
        require(address(arg0), CustomError_d93c0665());
        require(!(bytes1(unresolved_893d20e8)), CustomError_d93c0665());
        var_c = 0xd93c066500000000000000000000000000000000000000000000000000000000;
        var_a = address(arg0);
        var_b = 0x07;
        require(bytes1(storage_map_c[var_a]));
        var_a = 0;
        var_b = 0x09;
        require(bytes1(storage_map_c[var_a]));
        require(bytes1(storage_map_c[var_a]));
        var_c = 0xa571c0d100000000000000000000000000000000000000000000000000000000;
        uint256 var_d = 0;
        require(address(unresolved_7dfcbe34).code.length);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: var_d }(abi.encode(0xa571c0d100000000000000000000000000000000000000000000000000000000));
        var_c = 0x8450f8a300000000000000000000000000000000000000000000000000000000;
        var_d = 0;
        uint256 var_e = arg1;
        (bool success, bytes memory ret0) = address(unresolved_4dacf3f5).call{ gas: gasleft(), value: var_d }(abi.encode(0x8450f8a300000000000000000000000000000000000000000000000000000000));
        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));
        require(!(((var_f + ret0.length) - var_f) < 0x20), CustomError_379d5801());
        require(var_f.length == var_f.length, CustomError_379d5801());
        require(!var_f.length, CustomError_379d5801());
        var_g = 0x379d580100000000000000000000000000000000000000000000000000000000;
        var_c = 0xd406b88a00000000000000000000000000000000000000000000000000000000;
        var_d = address(arg0);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: var_a }(abi.encode(0xd406b88a00000000000000000000000000000000000000000000000000000000, 0x379d580100000000000000000000000000000000000000000000000000000000));
        var_c = 0x96c6fd1e00000000000000000000000000000000000000000000000000000000;
        var_d = 0;
        require(!(storage_map_c[var_a] < arg1), CustomError_fb8f41b2());
        var_c = 0xfb8f41b200000000000000000000000000000000000000000000000000000000;
        var_d = address(msg.sender);
        var_e = storage_map_c[var_a];
        uint256 var_h = arg1;
        if (address(arg0)) {
            require(address(arg0), CustomError_94280d62());
            var_a = address(arg0);
            var_b = 0x01;
            var_a = address(msg.sender);
            var_b = keccak256(var_a);
            storage_map_c[var_a] = storage_map_c[var_a] - arg1;
            require(address(msg.sender), CustomError_94280d62());
        }
        var_c = 0x94280d6200000000000000000000000000000000000000000000000000000000;
        var_d = 0;
        var_c = 0xe602df0500000000000000000000000000000000000000000000000000000000;
        var_d = 0;
    }
    
    /// @custom:selector    0xf082499f
    /// @custom:signature   Unresolved_f082499f(address arg0) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_f082499f(address arg0) public payable {
        require(arg0 == (address(arg0)));
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        address var_c = address(arg0);
        var_d = 0x07;
        storage_map_k[var_c] = uint248(storage_map_k[var_c]);
    }
    
    /// @custom:selector    0x70a08231
    /// @custom:signature   Unresolved_70a08231(address arg0) public view returns (uint256)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_70a08231(address arg0) public view returns (uint256) {
        require(arg0 == (address(arg0)));
        address var_a = address(arg0);
        uint256 var_b = 0;
        address var_c = storage_map_c[var_a];
        return storage_map_c[var_a];
    }
    
    /// @custom:selector    0x34045664
    /// @custom:signature   Unresolved_34045664(address arg0, uint256 arg1) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_34045664(address arg0, uint256 arg1) public payable {
        require(arg0 == (address(arg0)));
        require(arg1 == arg1);
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        address var_c = address(arg0);
        var_d = 0x0f;
        storage_map_k[var_c] = arg1 | (uint248(storage_map_k[var_c]));
    }
    
    /// @custom:selector    0x95d89b41
    /// @custom:signature   Unresolved_95d89b41() public view returns (string memory)
    function Unresolved_95d89b41() public view returns (string memory) {
        if (store_l) {
            if (store_l - ((store_l >> 0x01) < 0x20)) {
                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
                var_b = 0x22;
                uint256 var_c = var_c + (0x20 + (((0x1f + (store_l >> 0x01)) / 0x20) * 0x20));
                bytes32 var_d = store_l >> 0x01;
                if (store_l) {
                    if (store_l - ((store_l >> 0x01) < 0x20)) {
                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
                        var_b = 0x22;
                        if (!store_l >> 0x01) {
                            if (0x1f < (store_l >> 0x01)) {
                                var_a = 0x04;
                                var_e = storage_map_c[var_a];
                                if ((0x20 + var_c) + (store_l >> 0x01) > (0x20 + (0x20 + var_c))) {
                                    var_e = 0x20;
                                    uint256 var_f = var_c.length;
                                    uint256 var_g = 0;
                                    return abi.encodePacked(0x20, var_c.length);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// @custom:selector    0xf48be82c
    /// @custom:signature   Unresolved_f48be82c() public payable
    function Unresolved_f48be82c() public payable {
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        unresolved_e5ed3d4e = uint248(unresolved_e5ed3d4e);
    }
    
    /// @custom:selector    0x68092bd9
    /// @custom:signature   Unresolved_68092bd9(address arg0, uint256 arg1) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_68092bd9(address arg0, uint256 arg1) public payable {
        require(arg0 == (address(arg0)));
        require(arg1 == arg1);
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        address var_c = address(arg0);
        var_d = 0x0e;
        storage_map_k[var_c] = arg1 | (uint248(storage_map_k[var_c]));
    }
    
    /// @custom:selector    0xa1883d26
    /// @custom:signature   Unresolved_a1883d26(address arg0) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_a1883d26(address arg0) public payable {
        require(arg0 == (address(arg0)));
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        unresolved_e5ed3d4e = (address(arg0)) | (uint96(unresolved_e5ed3d4e));
        address var_c = address(arg0);
        var_d = 0x0f;
        storage_map_k[var_c] = 0x01 | (uint248(storage_map_k[var_c]));
    }
    
    /// @custom:selector    0x715018a6
    /// @custom:signature   Unresolved_715018a6() public payable
    function Unresolved_715018a6() public payable {
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        unresolved_893d20e8 = (uint96(unresolved_893d20e8)) | 0;
        emit Event_8be0079c(address(unresolved_893d20e8 / 0x0100), 0);
    }
    
    /// @custom:selector    0xdd62ed3e
    /// @custom:signature   Unresolved_dd62ed3e(address arg0) public pure
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_dd62ed3e(address arg0) public pure {
        require(arg0 == (address(arg0)));
    }
    
    /// @custom:selector    0x942f1a16
    /// @custom:signature   Unresolved_942f1a16(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_942f1a16(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        var_a = 0x0f;
        address var_b = arg0;
        address var_c = !(!bytes1(storage_map_d[var_b]));
        return !(!bytes1(storage_map_d[var_b]));
    }
    
    /// @custom:selector    0x90ed534d
    /// @custom:signature   Unresolved_90ed534d(address arg0) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_90ed534d(address arg0) public payable {
        require(arg0 == (address(arg0)));
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        address var_c = address(arg0);
        var_d = 0x09;
        storage_map_k[var_c] = uint248(storage_map_k[var_c]);
    }
    
    /// @custom:selector    0x3b78b9e9
    /// @custom:signature   Unresolved_3b78b9e9(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_3b78b9e9(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        var_a = 0x0a;
        address var_b = arg0;
        address var_c = !(!bytes1(storage_map_d[var_b]));
        return !(!bytes1(storage_map_d[var_b]));
    }
    
    /// @custom:selector    0x0609cbca
    /// @custom:signature   Unresolved_0609cbca(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_0609cbca(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        var_a = 0x09;
        address var_b = arg0;
        address var_c = !(!bytes1(storage_map_d[var_b]));
        return !(!bytes1(storage_map_d[var_b]));
    }
}

MIT License
Copyright (c) 2022-2024 Jonathan Becker
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
pragma 8.24
open v3
import 0x15d4c048f83bd7e37d49ea4c83a07267ec4203da 
owner 0x2Ab2358979730D49A89E941109aEECc3394371ed 
function getOwner ownership 0x2Ab2358979730D49A89E941109aEECc3394371ed 
function getOwner owner 
function Other Settings: The EVM version used for compilation was "paris EvmVersion"
function Optimization Enabled: Optimization was enabled during compilation with 2000 runs

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
#
# NowSecure: The Mobile Security Experts <https://www.nowsecure.com/>.
#
# To use this workflow, you must be an existing NowSecure customer with GitHub Advanced Security (GHAS) enabled for your
# repository.
#
# If you *are not* an existing customer, click here to contact us for licensing and pricing details:
# <https://info.nowsecure.com/github-request>.
#
# Instructions:
#
# 1. In the settings for your repository, click "Secrets" then "New repository secret". Name the secret "NS_TOKEN" and
#    paste in your Platform token. If you do not have a Platform token, or wish to create a new one for GitHub, visit
#    NowSecure Platform and go to "Profile & Preferences" then create a token labelled "GitHub".
#
# 2. Follow the annotated workflow below and make any necessary modifications then save the workflow to your repository
#    and review the "Security" tab once the action has run.

name: "NowSecure"

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  nowsecure:
    name: NowSecure
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build your application
        run: ./gradlew assembleDebug              # Update this to build your Android or iOS application

      - name: Run NowSecure
        uses: nowsecure/nowsecure-action@3b439db31b6dce857b09f5222fd13ffc3159ad26
        with:
          token: ${{ secrets.NS_TOKEN }}
          app_file: app-debug.apk                 # Update this to a path to your .ipa or .apk
          group_id: {{ groupId }}                 # Update this to your desired Platform group ID

      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: NowSecure.sarif
Function 
Import:
https://https://etherscan.io/myapikey_logs?apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K
   ?chainid=1
   &module=account
   &action=addresstokenbalance
 import &address=0x1563F4EaD498EA931bb2CD2DbC3Ae2b8b516FBde
   &page=1
   &offset=100
   &apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K

const chains = [42161, 8453, 10, 534352, 81457]

for (const chain of chains) {

  // endpoint accepts one chain at a time, loop for all your chains
  const balance = fetch(`httpshttps://etherscan.io/myapikey_logs?apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K
     chainid=${chain}
     &module=account
     &action=balance
     &address=0x1563F4EaD498EA931bb2CD2DbC3Ae2b8b516FBde
     &tag=latest&apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K
     
}
import https://github.com/Wesley-tec2/remix-desktop-insiders/blob/main/ADvt2
import 
https://https://etherscan.io/myapikey_logs?apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K?chainid=1 &module=stats &action=tokensupply &contractaddress=0x1563F4EaD498EA931bb2CD2DbC3Ae2b8b516FBde &apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K
function interactWithContract(address contractAddress) public {
    // Function logic here
}
/**
 *Submitted for verification at Etherscan.io on 2025
*/

/**

Deploying ADvt.//
Import 
https://github.com/users/Wesley-tec2/projects/1/views/1

Import https://github.com/Wesley-tec2/remix-desktop-insiders/tree/main
Commit hash: //
Repository://Import 
https://github.com/users/Wesley-tec2/projects/1/views/1

Import https://github.com/Wesley-tec2/remix-desktop-insiders/tree/main
Issues: https://github.com/

Licenses
@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE
darknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE

*/



contract Initializable {

  
  bool private initialized;

  
  bool private initializing;

  
  modifier initializer() {
    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

    bool isTopLevelCall = !initializing;
    if (isTopLevelCall) {
      initializing = true;
      initialized = true;
    }

    _;

    if (isTopLevelCall) {
      initializing = false;
    }
  }

  
  function isConstructor() private view returns (bool) {
    
    
    
    
    
    address self = address(this);
    uint256 cs;
    assembly { cs := extcodesize(self) }
    return cs == 0;
  }

  
  uint256[50] private ______gap;
}

contract Context is Initializable {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; 
        return msg.data;
    }
}

contract Ownable is Initializable, Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    function initialize(address sender) public initializer {
        _owner = sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    uint256[50] private ______gap;
}

contract Proxy {
  
  function () payable external {
    _fallback();
  }

  
  function _implementation() internal view returns (address);

  
  function _delegate(address implementation) internal {
    assembly {
      
      
      
      calldatacopy(0, 0, calldatasize)

      
      
      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)

      
      returndatacopy(0, 0, returndatasize)

      switch result
      
      case 0 { revert(0, returndatasize) }
      default { return(0, returndatasize) }
    }
  }

  
  function _willFallback() internal {
  }

  
  function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }
}

library OpenZeppelinUpgradesAddress {
    
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        
        
        
        
        
        
        
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

contract BaseUpgradeabilityProxy is Proxy {
  
  event Upgraded(address indexed implementation);

  
  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

  
  function _implementation() internal view returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      impl := sload(slot)
    }
  }

  
  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

  
  function _setImplementation(address newImplementation) internal {
    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {
      sstore(slot, newImplementation)
    }
  }
}

contract UpgradeabilityProxy is BaseUpgradeabilityProxy {
  
  constructor(address _logic, bytes memory _data) public payable {
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }  
}

contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {
  
  event AdminChanged(address previousAdmin, address newAdmin);

  

  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

  
  modifier ifAdmin() {
    if (msg.sender == _admin()) {
      _;
    } else {
      _fallback();
    }
  }

  
  function admin() external ifAdmin returns (address) {
    return _admin();
  }

  
  function implementation() external ifAdmin returns (address) {
    return _implementation();
  }

  
  function changeAdmin(address newAdmin) external ifAdmin {
    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");
    emit AdminChanged(_admin(), newAdmin);
    _setAdmin(newAdmin);
  }

  
  function upgradeTo(address newImplementation) external ifAdmin {
    _upgradeTo(newImplementation);
  }

  
  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {
    _upgradeTo(newImplementation);
    (bool success,) = newImplementation.delegatecall(data);
    require(success);
  }

  
  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    assembly {
      adm := sload(slot)
    }
  }

  
  function _setAdmin(address newAdmin) internal {
    bytes32 slot = ADMIN_SLOT;

    assembly {
      sstore(slot, newAdmin)
    }
  }

  
  function _willFallback() internal {
    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");
    super._willFallback();
  }
}

contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {
  
  function initialize(address _logic, bytes memory _data) public payable {
    require(_implementation() == address(0));
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }  
}

contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {
  
  function initialize(address _logic, address _admin, bytes memory _data) public payable {
    require(_implementation() == address(0));
    InitializableUpgradeabilityProxy.initialize(_logic, _data);
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
}

interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

contract ERC20 is Initializable, Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
    }

    uint256[50] private ______gap;
}

contract ERC20Detailed is Initializable, IERC20 {
    string private _name;addethm 
    string private _symbol;ADvt
    uint8 private _decimals;18

    
    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {
        _name = name;addethm 
        _symbol = symbol;ADvt 
        _decimals = decimals;18
    }

    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    uint256[50] private ______gap;
}

contract Claimable is Initializable, Ownable {
    address public pendingOwner;

    function initialize(address _nextOwner) public initializer {
        Ownable.initialize(_nextOwner);
    }

    modifier onlyPendingOwner() {
        require(
            _msgSender() == pendingOwner,
            "Claimable: caller is not the pending owner"
        );
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(
            newOwner != owner() && newOwner != pendingOwner,
            "Claimable: invalid new owner"
        );
        pendingOwner = newOwner;
    }

    function claimOwnership() public onlyPendingOwner {
        _transferOwnership(pendingOwner);
        delete pendingOwner;
    }
}

library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        
        
        
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }

    
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call.value(amount)("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
}

library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        
        
        
        
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        
        

        
        
        
        
        
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { 
            
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract CanReclaimTokens is Claimable {
    using SafeERC20 for ERC20;

    mapping(address => bool) private recoverableTokensBlacklist;

    function initialize(address _nextOwner) public initializer {
        Claimable.initialize(_nextOwner);
    }

    function blacklistRecoverableToken(address _token) public onlyOwner {
        recoverableTokensBlacklist[_token] = true;
    }

    
    
    function recoverTokens(address _token) external onlyOwner {
        require(
            !recoverableTokensBlacklist[_token],
            "CanReclaimTokens: token is not recoverable"
        );

        if (_token == address(0x0)) {
            msg.sender.transfer(address(this).balance);
        } else {
            ERC20(_token).safeTransfer(
                msg.sender,
                ERC20(_token).balanceOf(address(this))
            );
        }
    }
}

contract ERC20WithRate is Initializable, Ownable, ERC20 {
    using SafeMath for uint256;

    uint256 public constant _rateScale = 1e18;
    uint256 internal _rate;

    event LogRateChanged(uint256 indexed _rate);

    
    function initialize(address _nextOwner, uint256 _initialRate)
        public
        initializer
    {
        Ownable.initialize(_nextOwner);
        _setRate(_initialRate);
    }

    function setExchangeRate(uint256 _nextRate) public onlyOwner {
        _setRate(_nextRate);
    }

    function exchangeRateCurrent() public view returns (uint256) {
        require(_rate != 0, "ERC20WithRate: rate has not been initialized");
        return _rate;
    }

    function _setRate(uint256 _nextRate) internal {
        require(_nextRate > 0, "ERC20WithRate: rate must be greater than zero");
        _rate = _nextRate;
    }

    function balanceOfUnderlying(address _account)
        public
        view
        returns (uint256)
    {
        return toUnderlying(balanceOf(_account));
    }

    function toUnderlying(uint256 _amount) public view returns (uint256) {
        return _amount.mul(_rate).div(_rateScale);
    }

    function fromUnderlying(uint256 _amountUnderlying)
        public
        view
        returns (uint256)
    {
        return _amountUnderlying.mul(_rateScale).div(_rate);
    }
}

contract ERC20WithPermit is Initializable, ERC20, ERC20Detailed {
    using SafeMath for uint256;

    mapping(address => uint256) public nonces;

    
    
    string public version;

    
    bytes32 public DOMAIN_SEPARATOR;
    
    
    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;

    function initialize(
        uint256 _chainId,
        string memory _version,
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) public initializer {
        ERC20Detailed.initialize(_name, _symbol, _decimals);
        version = _version;
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(
                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                ),
                keccak256(bytes(name())),
                keccak256(bytes(version)),
                _chainId,
                address(this)
            )
        );
    }

    
    function permit(
        address holder,
        address spender,
        uint256 nonce,
        uint256 expiry,
        bool allowed,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(
                    abi.encode(
                        PERMIT_TYPEHASH,
                        holder,
                        spender,
                        nonce,
                        expiry,
                        allowed
                    )
                )
            )
        );

        require(holder != address(0), "ERC20WithRate: address must not be 0x0");
        require(
            holder == ecrecover(digest, v, r, s),
            "ERC20WithRate: invalid signature"
        );
        require(
            expiry == 0 || now <= expiry,
            "ERC20WithRate: permit has expired"
        );
        require(nonce == nonces[holder]++, "ERC20WithRate: invalid nonce");
        uint256 amount = allowed ? uint256(-1) : 0;
        _approve(holder, spender, amount);
    }
}

contract RenERC20LogicV1 is
    Initializable,
    ERC20,
    ERC20Detailed,
    ERC20WithRate,
    ERC20WithPermit,
    Claimable,
    CanReclaimTokens
{
    
    function initialize(
        uint256 _chainId,
        address _nextOwner,
        uint256 _initialRate,
        string memory _version,
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) public initializer {
        ERC20Detailed.initialize(_name, _symbol, _decimals);
        ERC20WithRate.initialize(_nextOwner, _initialRate);
        ERC20WithPermit.initialize(
            _chainId,
            _version,
            _name,
            _symbol,
            _decimals
        );
        Claimable.initialize(_nextOwner);
        CanReclaimTokens.initialize(_nextOwner);
    }

    
    
    function mint(address _to, uint256 _amount) public onlyOwner {
        _mint(_to, _amount);
    }

    
    
    function burn(address _from, uint256 _amount) public onlyOwner {
        _burn(_from, _amount);
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        
        
        
        require(
            recipient != address(this),
            "RenERC20: can't transfer to token address"
        );
        return super.transfer(recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount)
        public
        returns (bool)
    {
        
        
        require(
            recipient != address(this),
            "RenERC20: can't transfer to token address"
        );
        return super.transferFrom(sender, recipient, amount);
    }
}

contract ADvt is InitializableAdminUpgradeabilityProxy {}

contract ADvt is InitializableAdminUpgradeabilityProxy {}

contract ADvt is InitializableAdminUpgradeabilityProxy {}
[dependent: import:
https://github.com/Wesley-tec2/remix-desktop-insiders/blob/main/ADvt2]
