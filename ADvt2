// SPDX-License-Identifier:GPL-3.0 
pragma solidity >=0.8.24;
/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`// SPDX-License-Identifier: GPL-3.0 pragma solidity >=0.7.0 <0.9.0;// SPDX-License-Identifier: GPL-3.0 pragma solidity >=0.7.0 <0.9.0;// SPDX-License-Identifier: GPL-3.0 pragma solidity >=0.7.0 <0.9.0;// SPDX-License-Identifier: GPL-3.0 pragma solidity >=0.7.0 <0.9.0;// SPDX-License-Identifier: GPL-3.0 pragma solidity >=0.7.0 <0.9.0;// SPDX-License-Identifier: GPL-3.0 pragma solidity >=0.7.0 <0.9.0;// SPDX-License-Identifier: GPL-3.0 pragma solidity >=0.7.0 <0.9.0;// SPDX-License-Identifier: GPL-3.0 pragma solidity >=0.7.0 <0.9.0;)
 * and `uint256` (`UintSet`) are supported.
 *
 * [WARNING]
 * ====
 * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure
 * unusable.
 * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.
 *
 * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an
 * array of EnumerableSet.
 * ====
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;
        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping(bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) {
            // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            if (lastIndex != toDeleteIndex) {
                bytes32 lastValue = set._values[lastIndex];

                // Move the last value to the index where the value to delete is
                set._values[toDeleteIndex] = lastValue;
                // Update the index for the moved value
                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex
            }

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false; 
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value)
        private
        view
        returns (bool)
    {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Set storage set, uint256 index)
        private
        view
        returns (bytes32)
    {
        return set._values[index];
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function _values(Set storage set) private view returns (bytes32[] memory) {
        return set._values;
    }

    // Bytes32Set

    struct Bytes32Set {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(Bytes32Set storage set, bytes32 value)
        internal
        returns (bool)
    {
        return _add(set._inner, value);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(Bytes32Set storage set, bytes32 value) 
        internal
        returns (bool)
    {
        return _remove(set._inner, value);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(Bytes32Set storage set, bytes32 value)
        internal
        view
        returns (bool)
    {
        return _contains(set._inner, value);
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(Bytes32Set storage set, uint256 index)
        internal
        view
        returns (bytes32)
    {
        return _at(set._inner, index);
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(Bytes32Set storage set)
        internal
        view
        returns (bytes32[] memory)
    {
        bytes32[] memory store = _values(set._inner);
        bytes32[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value)
        internal
        returns (bool)
    {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value)
        internal
        returns (bool)
    {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value)
        internal
        view
        returns (bool)
    {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressSet storage set, uint256 index)
        internal
        view
        returns (address)
    {
        return address(uint160(uint256(_at(set._inner, index))));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(AddressSet storage set)
        internal
        view
        returns (address[] memory)
    {
        bytes32[] memory store = _values(set._inner);
        address[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }

    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value)
        internal
        returns (bool)
    {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value)
        internal
        view
        returns (bool)
    {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(UintSet storage set, uint256 index)
        internal
        view
        returns (uint256)
    {
        return uint256(_at(set._inner, index));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(UintSet storage set)
        internal
        view
        returns (uint256[] memory)
    {
        bytes32[] memory store = _values(set._inner);
        uint256[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }
}

// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol

// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/ERC165.sol

// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.24;

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override
        returns (bool)
    {
        return interfaceId == type(IERC165).interfaceId;
    }
}

// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/Math.sol

// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)

pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    enum Rounding {
        Down, // Toward negative infinity
        Up, // Toward infinity
        Zero // Toward zero
    }

    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a == 0 ? 0 : (a - 1) / b + 1;
    }

    /**
     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
     * with further edits by Uniswap Labs also under MIT license.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2^256 + prod0.
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(x, y, not(0))
                prod0 := mul(x, y)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                return prod0 / denominator;
            }

            // Make sure the result is less than 2^256. Also prevents denominator == 0.
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0].
            uint256 remainder;
            assembly {
                // Compute remainder using mulmod.
                remainder := mulmod(x, y, denominator)

                // Subtract 256 bit number from 512 bit number.
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
            // See https://cs.stackexchange.com/q/138556/92363.

            // Does not overflow because the denominator cannot be zero at this stage in the function.
            uint256 twos = denominator & (~denominator + 1);
            assembly {
                // Divide denominator by twos.
                denominator := div(denominator, twos)

                // Divide [prod1 prod0] by twos.
                prod0 := div(prod0, twos)

                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
                twos := add(div(sub(0, twos), twos), 1)
            }

            // Shift in bits from prod1 into prod0.
            prod0 |= prod1 * twos;

            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
            // four bits. That is, denominator * inv = 1 mod 2^4.
            uint256 inverse = (3 * denominator) ^ 2;

            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
            // in modular arithmetic, doubling the correct bits in each step.
            inverse *= 2 - denominator * inverse; // inverse mod 2^8
            inverse *= 2 - denominator * inverse; // inverse mod 2^16
            inverse *= 2 - denominator * inverse; // inverse mod 2^32
            inverse *= 2 - denominator * inverse; // inverse mod 2^64
            inverse *= 2 - denominator * inverse; // inverse mod 2^128
            inverse *= 2 - denominator * inverse; // inverse mod 2^256

            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inverse;
            return result;
        }
    }

    /**
     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator,
        Rounding rounding
    ) internal pure returns (uint256) {
        uint256 result = mulDiv(x, y, denominator);
        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
            result += 1;
        }
        return result;
    }

    /**
     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
     *
     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
     */
    function sqrt(uint256 a) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
        //
        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
        //
        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
        //
        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
        uint256 result = 1 << (log2(a) >> 1);

        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
        // into the expected uint128 result.
        unchecked {
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            return min(result, a / result);
        }
    }

    /**
     * @notice Calculates sqrt(a), following the selected rounding direction.
     */
    function sqrt(uint256 a, Rounding rounding)
        internal
        pure
        returns (uint256)
    {
        unchecked {
            uint256 result = sqrt(a);
            return
                result +
                (rounding == Rounding.Up && result * result < a ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 2, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 128;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 64;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 32;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 16;
            }
            if (value >> 8 > 0) {
                value >>= 8;
                result += 8;
            }
            if (value >> 4 > 0) {
                value >>= 4;
                result += 4;
            }
            if (value >> 2 > 0) {
                value >>= 2;
                result += 2;
            }
            if (value >> 1 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value, Rounding rounding)
        internal
        pure
        returns (uint256)
    {
        unchecked {
            uint256 result = log2(value);
            return
                result +
                (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 10, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >= 10**64) {
                value /= 10**64;
                result += 64;
            }
            if (value >= 10**32) {
                value /= 10**32;
                result += 32;
            }
            if (value >= 10**16) {
                value /= 10**16;
                result += 16;
            }
            if (value >= 10**8) {
                value /= 10**8;
                result += 8;
            }
            if (value >= 10**4) {
                value /= 10**4;
                result += 4;
            }
            if (value >= 10**2) {
                value /= 10**2;
                result += 2;
            }
            if (value >= 10**1) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value, Rounding rounding)
        internal
        pure
        returns (uint256)
    {
        unchecked {
            uint256 result = log10(value);
            return
                result +
                (rounding == Rounding.Up && 10**result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 256, rounded down, of a positive value.
     * Returns 0 if given 0.
     *
     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
     */
    function log256(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 16;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 8;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 4;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 2;
            }
            if (value >> 8 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log256(uint256 value, Rounding rounding)
        internal
        pure
        returns (uint256)
    {
        unchecked {
            uint256 result = log256(value);
            return
                result +
                (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
        }
    }
}

// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol

// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)

pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        unchecked {
            uint256 length = Math.log10(value) + 1;
            string memory buffer = new string(length);
            uint256 ptr;
            /// @solidity memory-safe-assembly
            assembly {
                ptr := add(buffer, add(32, length))
            }
            while (true) {
                ptr--;
                /// @solidity memory-safe-assembly
                assembly {
                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
                }
                value /= 10;
                if (value == 0) break;
            }
            return buffer;
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        unchecked {
            return toHexString(value, Math.log256(value) + 1);
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length)
        internal
        pure
        returns (string memory)
    {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }
}

// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/IAccessControl.sol

// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)

pragma solidity ^0.8.0;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account)
        external
        view
        returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;
}

// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/IAccessControlEnumerable.sol

// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)

pragma solidity ^0.8.0;

/**
 * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.
 */
interface IAccessControlEnumerable is IAccessControl {
    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index)
        external
        view
        returns (address);

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
}

// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol

// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
} 
Import:
https://api.etherscan.io/v2/api
   ?chainid=1
   &module=account
   &action=addresstokenbalance
   &address=0x1563F4EaD498EA931bb2CD2DbC3Ae2b8b516FBde
   &page=1
   &offset=100
   &apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K

// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol

// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)
// SPDX-License-Identifier: 
pragma solidity 0.7.4;

import "./0x1563F4EaD498EA931bb2CD2DbC3Ae2b8b516FBde.sol";


/**
 * @title ADvt
 * @dev This is the Master contract with all  ADvt getter functions and delegate call to ADvt
 * The logic for the functions on this contract is saved on the ethics net
 ;
        bytesVars[_CURRENT_CHALLENGE] = bytes32("1");
        uints[_DIFFICULTY] = 100;
        uints[_TIME_TARGET] = 240;
        uints[_TARGET_MINERS] = 200;
        uints[_CURRENT_REWARD] = 1e18;
        uints[_DISPUTE_FEE] = 500e18;
        uints[_STAKE_AMOUNT] = 500e18;
        uints[_TIME_OF_LAST_NEW_VALUE] = block.timestamp - 240;

        currentMiners[0].value = 1;
        currentMiners[1].value = 2;
        currentMiners[2].value = 3;
        currentMiners[3].value = 4;
        currentMiners[4].value = 5;

        // Bootstraping Request Queue
        for (uint256 index = 1; index < 51; index++) {
            Request storage req = requestDetails[index];
            req.apiUintVars[_REQUEST_Q_POSITION] = index;
            requestIdByRequestQIndex[index] = index;
        }

        assembly {
            sstore(_EIP_SLOT, _tContract)
        }

        emit ADvt Address(_tContract);
    }

    /**
     * @dev This function allows the Deity to set a new deity
     * @param _newDeity the new Deity in the contract
     */
    function changeDeity(address _newDeity) external {
        require(msg.sender == addresses[_DEITY]);
        addresses[_DEITY] = _newDeity;
    }

    /**
     * @dev This function allows the owner to set a new _owner
     * @param _newOwner the new Owner in the contract
     */
    function changeOwner(address _newOwner) external {
        require(msg.sender == addresses[_OWNER]);
        addresses[_OWNER] = _newOwner;
    }

    /**
     * @dev  allows for the deity to make fast upgrades.  Deity should be 0 address if decentralized
     * @param _tContract the address of the ADvt Contract
     */
    function changeTellorContract(address _tContract) external {
        require(msg.sender == addresses[_DEITY]);
        addresses[_TELLOR_CONTRACT] = _tContract;

      
    /**
     * @dev This is the internal function that allows for delegate calls to the ADvt logic
     * contract address
     */0x1563F4EaD498EA931bb2CD2DbC3Ae2b8b516FBde
    function _delegate(address implementation) internal virtual {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(
                gas(),
                implementation,
                0,
                calldatasize(),
                0,
                0
            )

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /**
     * @dev This is the fallback function that allows contracts to call the ADvt
     * contract at the address stored
     */
    fallback() external payable {
        address addr = addresses[_ADvt_CONTRACT];
        _delegate(addr);
    }
}
pragma solidity ^0.8.0;

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with a standardized message including the required role.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     *
     * _Available since v4.1._
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role);
        _;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override
        returns (bool)
    {
        return
            interfaceId == type(IAccessControl).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account)
        public
        view
        virtual
        override
        returns (bool)
    {
        return _roles[role].members[account];
    }

    /**
     * @dev Revert with a standard message if `_msgSender()` is missing `role`.
     * Overriding this function changes the behavior of the {onlyRole} modifier.
     *
     * Format of the revert message is described in {_checkRole}.
     *
     * _Available since v4.6._
     */
    function _checkRole(bytes32 role) internal view virtual {
        _checkRole(role, _msgSender());
    }

    /**
     * @dev Revert with a standard message if `account` is missing `role`.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is mis
Dependent:https://github.com/Wesley-tec2/remix-desktop-insiders/blob/main/ADvt2
/// @title            Decompiled Contract
/// @author           Jonathan Becker <jonathan@jbecker.dev>
/// @custom:version   heimdall-rs v0.8.4
///
/// @notice           This contract was decompiled using the heimdall-rs decompiler.
///                     It was generated directly by tracing the EVM opcodes from this contract.
///                     As a result, it may not compile or even be valid solidity code.
///                     Despite this, it should be obvious what each function does. Overall
///                     logic should have been preserved throughout decompiling.
///
/// @custom:github    You can find the open-source decompiler here:
///                       https://heimdall.rs

contract DecompiledContract {
    uint256 public constant unresolved_2e0f2625 = 1000000000000000000;
    uint256 public constant unresolved_313ce567 = 18;
    
    uint256 public unresolved_378dc3dc;
    address public unresolved_893d20e8;
    uint256 public unresolved_a071dcf4;
    bytes32 store_b;
    bool public unresolved_e5ed3d4e;
    address public unresolved_4dacf3f5;
    address public unresolved_7dfcbe34;
    mapping(bytes32 => bytes32) storage_map_c;
    mapping(bytes32 => bytes32) storage_map_d;
    uint256 public unresolved_18160ddd;
    bytes32 store_l;
    mapping(bytes32 => bytes32) storage_map_k;
    
    event Event_8c5be1e5();
    error CustomError_00000000();
    event Event_8be0079c();
    
    /// @custom:selector    0x06fdde03
    /// @custom:signature   Unresolved_06fdde03() public view returns (string memory)
    function Unresolved_06fdde03() public view returns (string memory) {
        if (store_b) {
            if (store_b - ((store_b >> 0x01) < 0x20)) {
                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
                var_b = 0x22;
                uint256 var_c = var_c + (0x20 + (((0x1f + (store_b >> 0x01)) / 0x20) * 0x20));
                bytes32 var_d = store_b >> 0x01;
                if (store_b) {
                    if (store_b - ((store_b >> 0x01) < 0x20)) {
                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
                        var_b = 0x22;
                        if (!store_b >> 0x01) {
                            if (0x1f < (store_b >> 0x01)) {
                                var_a = 0x03;
                                var_e = storage_map_c[var_a];
                                if ((0x20 + var_c) + (store_b >> 0x01) > (0x20 + (0x20 + var_c))) {
                                    var_e = 0x20;
                                    uint256 var_f = var_c.length;
                                    uint256 var_g = 0;
                                    return abi.encodePacked(0x20, var_c.length);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// @custom:selector    0x4838d165
    /// @custom:signature   Unresolved_4838d165(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_4838d165(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        var_a = 0x0e;
        address var_b = arg0;
        address var_c = !(!bytes1(storage_map_d[var_b]));
        return !(!bytes1(storage_map_d[var_b]));
    }
    
    /// @custom:selector    0x23b872dd
    /// @custom:signature   Unresolved_23b872dd(address arg0) public pure
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_23b872dd(address arg0) public pure {
        require(arg0 == (address(arg0)));
    }
    
    /// @custom:selector    0xee3b0d62
    /// @custom:signature   Unresolved_ee3b0d62(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_ee3b0d62(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        var_a = 0x07;
        address var_b = arg0;
        address var_c = !(!bytes1(storage_map_d[var_b]));
        return !(!bytes1(storage_map_d[var_b]));
    }
    
    /// @custom:selector    0x298bb0f9
    /// @custom:signature   Unresolved_298bb0f9(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_298bb0f9(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        address var_a = address(arg0);
        var_b = 0x09;
        address var_c = !(!bytes1(storage_map_c[var_a]));
        return !(!bytes1(storage_map_c[var_a]));
    }
    
    /// @custom:selector    0x07184e17
    /// @custom:signature   Unresolved_07184e17(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_07184e17(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        address var_a = address(arg0);
        var_b = 0x07;
        address var_c = !(!bytes1(storage_map_c[var_a]));
        return !(!bytes1(storage_map_c[var_a]));
    }
    
    /// @custom:selector    0x095ea7b3
    /// @custom:signature   Unresolved_095ea7b3(address arg0, uint256 arg1) public payable returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_095ea7b3(address arg0, uint256 arg1) public payable returns (bool) {
        require(arg0 == (address(arg0)));
        require(address(msg.sender), CustomError_94280d62());
        require(address(arg0), CustomError_94280d62());
        address var_a = address(msg.sender);
        var_b = 0x01;
        var_a = address(arg0);
        address var_b = keccak256(var_a);
        storage_map_c[var_a] = arg1;
        require(!0x01, CustomError_94280d62());
        var_c = 0x01;
        return 0x01;
        uint256 var_c = arg1;
        emit Event_8c5be1e5(address(msg.sender), address(arg0), arg1);
        var_c = 0x01;
        return 0x01;
        var_c = 0x94280d6200000000000000000000000000000000000000000000000000000000;
        uint256 var_d = 0;
        var_c = 0xe602df0500000000000000000000000000000000000000000000000000000000;
        var_d = 0;
    }
    
    /// @custom:selector    0xf2fde38b
    /// @custom:signature   Unresolved_f2fde38b(address arg0) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_f2fde38b(address arg0) public payable {
        require(arg0 == (address(arg0)));
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        require(address(arg0), CustomError_1e4fbdf7());
        unresolved_893d20e8 = (uint96(unresolved_893d20e8)) | (0x0100 * (address(arg0)));
        emit Event_8be0079c(address(unresolved_893d20e8 / 0x0100), address(arg0));
        var_a = 0x1e4fbdf700000000000000000000000000000000000000000000000000000000;
        var_b = 0;
    }
    
    /// @custom:selector    0xa9059cbb
    /// @custom:signature   Unresolved_a9059cbb(address arg0, uint256 arg1) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_a9059cbb(address arg0, uint256 arg1) public payable {
        require(arg0 == (address(arg0)));
        require(address(msg.sender), CustomError_d93c0665());
        require(address(arg0), CustomError_d93c0665());
        require(!(bytes1(unresolved_893d20e8)), CustomError_d93c0665());
        var_a = 0xd93c066500000000000000000000000000000000000000000000000000000000;
        address var_b = address(msg.sender);
        var_c = 0x07;
        require(bytes1(storage_map_d[var_b]));
        var_b = address(arg0);
        var_c = 0x09;
        require(bytes1(storage_map_d[var_b]));
        require(bytes1(storage_map_d[var_b]));
        var_a = 0xa571c0d100000000000000000000000000000000000000000000000000000000;
        address var_d = address(arg0);
        require(address(unresolved_7dfcbe34).code.length);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: 0 }(abi.encode(0xa571c0d100000000000000000000000000000000000000000000000000000000));
        var_a = 0x8450f8a300000000000000000000000000000000000000000000000000000000;
        var_d = address(arg0);
        uint256 var_e = arg1;
        (bool success, bytes memory ret0) = address(unresolved_4dacf3f5).call{ gas: gasleft(), value: 0 }(abi.encode(0x8450f8a300000000000000000000000000000000000000000000000000000000));
        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));
        require(!(((var_f + ret0.length) - var_f) < 0x20), CustomError_379d5801());
        require(var_f.length == var_f.length, CustomError_379d5801());
        require(!var_f.length, CustomError_379d5801());
        var_g = 0x379d580100000000000000000000000000000000000000000000000000000000;
        var_a = 0xd406b88a00000000000000000000000000000000000000000000000000000000;
        var_d = address(msg.sender);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: 0 }(abi.encode(0xd406b88a00000000000000000000000000000000000000000000000000000000, 0x379d580100000000000000000000000000000000000000000000000000000000));
        var_a = 0xec442f0500000000000000000000000000000000000000000000000000000000;
        var_d = 0;
        var_a = 0x96c6fd1e00000000000000000000000000000000000000000000000000000000;
        var_d = 0;
    }
    
    /// @custom:selector    0x42966c68
    /// @custom:signature   Unresolved_42966c68(uint256 arg0) public payable
    /// @param              arg0 ["uint256", "bytes32", "int256"]
    function Unresolved_42966c68(uint256 arg0) public payable {
        require(address(msg.sender), CustomError_d93c0665());
        require(!(bytes1(unresolved_893d20e8)), CustomError_d93c0665());
        var_a = 0xd93c066500000000000000000000000000000000000000000000000000000000;
        address var_b = address(msg.sender);
        var_c = 0x07;
        require(bytes1(storage_map_d[var_b]));
        var_b = 0;
        var_c = 0x09;
        require(bytes1(storage_map_d[var_b]));
        require(bytes1(storage_map_d[var_b]));
        var_a = 0xa571c0d100000000000000000000000000000000000000000000000000000000;
        uint256 var_d = 0;
        require(address(unresolved_7dfcbe34).code.length);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: var_b }(abi.encode(0xa571c0d100000000000000000000000000000000000000000000000000000000));
        var_a = 0x8450f8a300000000000000000000000000000000000000000000000000000000;
        var_d = 0;
        uint256 var_e = arg0;
        (bool success, bytes memory ret0) = address(unresolved_4dacf3f5).call{ gas: gasleft(), value: var_b }(abi.encode(0x8450f8a300000000000000000000000000000000000000000000000000000000));
        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));
        require(!(((var_f + ret0.length) - var_f) < 0x20), CustomError_379d5801());
        require(var_f.length == var_f.length, CustomError_379d5801());
        require(!var_f.length, CustomError_379d5801());
        var_g = 0x379d580100000000000000000000000000000000000000000000000000000000;
        var_a = 0xd406b88a00000000000000000000000000000000000000000000000000000000;
        var_d = address(msg.sender);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: var_b }(abi.encode(0xd406b88a00000000000000000000000000000000000000000000000000000000, 0x379d580100000000000000000000000000000000000000000000000000000000));
        var_a = 0x96c6fd1e00000000000000000000000000000000000000000000000000000000;
        var_d = 0;
    }
    
    /// @custom:selector    0x79cc6790
    /// @custom:signature   Unresolved_79cc6790(address arg0, uint256 arg1) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_79cc6790(address arg0, uint256 arg1) public payable {
        require(arg0 == (address(arg0)));
        address var_a = address(arg0);
        var_b = 0x01;
        var_a = address(msg.sender);
        address var_b = keccak256(var_a);
        require(storage_map_c[var_a] == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, CustomError_d93c0665());
        require(address(arg0), CustomError_d93c0665());
        require(!(bytes1(unresolved_893d20e8)), CustomError_d93c0665());
        var_c = 0xd93c066500000000000000000000000000000000000000000000000000000000;
        var_a = address(arg0);
        var_b = 0x07;
        require(bytes1(storage_map_c[var_a]));
        var_a = 0;
        var_b = 0x09;
        require(bytes1(storage_map_c[var_a]));
        require(bytes1(storage_map_c[var_a]));
        var_c = 0xa571c0d100000000000000000000000000000000000000000000000000000000;
        uint256 var_d = 0;
        require(address(unresolved_7dfcbe34).code.length);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: var_d }(abi.encode(0xa571c0d100000000000000000000000000000000000000000000000000000000));
        var_c = 0x8450f8a300000000000000000000000000000000000000000000000000000000;
        var_d = 0;
        uint256 var_e = arg1;
        (bool success, bytes memory ret0) = address(unresolved_4dacf3f5).call{ gas: gasleft(), value: var_d }(abi.encode(0x8450f8a300000000000000000000000000000000000000000000000000000000));
        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));
        require(!(((var_f + ret0.length) - var_f) < 0x20), CustomError_379d5801());
        require(var_f.length == var_f.length, CustomError_379d5801());
        require(!var_f.length, CustomError_379d5801());
        var_g = 0x379d580100000000000000000000000000000000000000000000000000000000;
        var_c = 0xd406b88a00000000000000000000000000000000000000000000000000000000;
        var_d = address(arg0);
        (bool success, bytes memory ret0) = address(unresolved_7dfcbe34).call{ gas: gasleft(), value: var_a }(abi.encode(0xd406b88a00000000000000000000000000000000000000000000000000000000, 0x379d580100000000000000000000000000000000000000000000000000000000));
        var_c = 0x96c6fd1e00000000000000000000000000000000000000000000000000000000;
        var_d = 0;
        require(!(storage_map_c[var_a] < arg1), CustomError_fb8f41b2());
        var_c = 0xfb8f41b200000000000000000000000000000000000000000000000000000000;
        var_d = address(msg.sender);
        var_e = storage_map_c[var_a];
        uint256 var_h = arg1;
        if (address(arg0)) {
            require(address(arg0), CustomError_94280d62());
            var_a = address(arg0);
            var_b = 0x01;
            var_a = address(msg.sender);
            var_b = keccak256(var_a);
            storage_map_c[var_a] = storage_map_c[var_a] - arg1;
            require(address(msg.sender), CustomError_94280d62());
        }
        var_c = 0x94280d6200000000000000000000000000000000000000000000000000000000;
        var_d = 0;
        var_c = 0xe602df0500000000000000000000000000000000000000000000000000000000;
        var_d = 0;
    }
    
    /// @custom:selector    0xf082499f
    /// @custom:signature   Unresolved_f082499f(address arg0) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_f082499f(address arg0) public payable {
        require(arg0 == (address(arg0)));
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        address var_c = address(arg0);
        var_d = 0x07;
        storage_map_k[var_c] = uint248(storage_map_k[var_c]);
    }
    
    /// @custom:selector    0x70a08231
    /// @custom:signature   Unresolved_70a08231(address arg0) public view returns (uint256)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_70a08231(address arg0) public view returns (uint256) {
        require(arg0 == (address(arg0)));
        address var_a = address(arg0);
        uint256 var_b = 0;
        address var_c = storage_map_c[var_a];
        return storage_map_c[var_a];
    }
    
    /// @custom:selector    0x34045664
    /// @custom:signature   Unresolved_34045664(address arg0, uint256 arg1) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_34045664(address arg0, uint256 arg1) public payable {
        require(arg0 == (address(arg0)));
        require(arg1 == arg1);
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        address var_c = address(arg0);
        var_d = 0x0f;
        storage_map_k[var_c] = arg1 | (uint248(storage_map_k[var_c]));
    }
    
    /// @custom:selector    0x95d89b41
    /// @custom:signature   Unresolved_95d89b41() public view returns (string memory)
    function Unresolved_95d89b41() public view returns (string memory) {
        if (store_l) {
            if (store_l - ((store_l >> 0x01) < 0x20)) {
                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
                var_b = 0x22;
                uint256 var_c = var_c + (0x20 + (((0x1f + (store_l >> 0x01)) / 0x20) * 0x20));
                bytes32 var_d = store_l >> 0x01;
                if (store_l) {
                    if (store_l - ((store_l >> 0x01) < 0x20)) {
                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;
                        var_b = 0x22;
                        if (!store_l >> 0x01) {
                            if (0x1f < (store_l >> 0x01)) {
                                var_a = 0x04;
                                var_e = storage_map_c[var_a];
                                if ((0x20 + var_c) + (store_l >> 0x01) > (0x20 + (0x20 + var_c))) {
                                    var_e = 0x20;
                                    uint256 var_f = var_c.length;
                                    uint256 var_g = 0;
                                    return abi.encodePacked(0x20, var_c.length);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// @custom:selector    0xf48be82c
    /// @custom:signature   Unresolved_f48be82c() public payable
    function Unresolved_f48be82c() public payable {
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        unresolved_e5ed3d4e = uint248(unresolved_e5ed3d4e);
    }
    
    /// @custom:selector    0x68092bd9
    /// @custom:signature   Unresolved_68092bd9(address arg0, uint256 arg1) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    /// @param              arg1 ["uint256", "bytes32", "int256"]
    function Unresolved_68092bd9(address arg0, uint256 arg1) public payable {
        require(arg0 == (address(arg0)));
        require(arg1 == arg1);
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        address var_c = address(arg0);
        var_d = 0x0e;
        storage_map_k[var_c] = arg1 | (uint248(storage_map_k[var_c]));
    }
    
    /// @custom:selector    0xa1883d26
    /// @custom:signature   Unresolved_a1883d26(address arg0) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_a1883d26(address arg0) public payable {
        require(arg0 == (address(arg0)));
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        unresolved_e5ed3d4e = (address(arg0)) | (uint96(unresolved_e5ed3d4e));
        address var_c = address(arg0);
        var_d = 0x0f;
        storage_map_k[var_c] = 0x01 | (uint248(storage_map_k[var_c]));
    }
    
    /// @custom:selector    0x715018a6
    /// @custom:signature   Unresolved_715018a6() public payable
    function Unresolved_715018a6() public payable {
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        unresolved_893d20e8 = (uint96(unresolved_893d20e8)) | 0;
        emit Event_8be0079c(address(unresolved_893d20e8 / 0x0100), 0);
    }
    
    /// @custom:selector    0xdd62ed3e
    /// @custom:signature   Unresolved_dd62ed3e(address arg0) public pure
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_dd62ed3e(address arg0) public pure {
        require(arg0 == (address(arg0)));
    }
    
    /// @custom:selector    0x942f1a16
    /// @custom:signature   Unresolved_942f1a16(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_942f1a16(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        var_a = 0x0f;
        address var_b = arg0;
        address var_c = !(!bytes1(storage_map_d[var_b]));
        return !(!bytes1(storage_map_d[var_b]));
    }
    
    /// @custom:selector    0x90ed534d
    /// @custom:signature   Unresolved_90ed534d(address arg0) public payable
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_90ed534d(address arg0) public payable {
        require(arg0 == (address(arg0)));
        require(msg.sender == (address(unresolved_893d20e8 / 0x0100)), CustomError_118cdaa7());
        var_a = 0x118cdaa700000000000000000000000000000000000000000000000000000000;
        address var_b = msg.sender;
        address var_c = address(arg0);
        var_d = 0x09;
        storage_map_k[var_c] = uint248(storage_map_k[var_c]);
    }
    
    /// @custom:selector    0x3b78b9e9
    /// @custom:signature   Unresolved_3b78b9e9(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_3b78b9e9(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        var_a = 0x0a;
        address var_b = arg0;
        address var_c = !(!bytes1(storage_map_d[var_b]));
        return !(!bytes1(storage_map_d[var_b]));
    }
    
    /// @custom:selector    0x0609cbca
    /// @custom:signature   Unresolved_0609cbca(address arg0) public view returns (bool)
    /// @param              arg0 ["address", "uint160", "bytes20", "int160"]
    function Unresolved_0609cbca(address arg0) public view returns (bool) {
        require(arg0 == (address(arg0)));
        var_a = 0x09;
        address var_b = arg0;
        address var_c = !(!bytes1(storage_map_d[var_b]));
        return !(!bytes1(storage_map_d[var_b]));
    }
}

MIT License
Copyright (c) 2022-2024 Jonathan Becker
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
pragma 8.24
open v3
import 0x15d4c048f83bd7e37d49ea4c83a07267ec4203da 
owner 0x2Ab2358979730D49A89E941109aEECc3394371ed 
function getOwner ownership 0x2Ab2358979730D49A89E941109aEECc3394371ed 
function getOwner owner 
function Other Settings: The EVM version used for compilation was "paris EvmVersion"
function Optimization Enabled: Optimization was enabled during compilation with 2000 runs

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
#
# NowSecure: The Mobile Security Experts <https://www.nowsecure.com/>.
#
# To use this workflow, you must be an existing NowSecure customer with GitHub Advanced Security (GHAS) enabled for your
# repository.
#
# If you *are not* an existing customer, click here to contact us for licensing and pricing details:
# <https://info.nowsecure.com/github-request>.
#
# Instructions:
#
# 1. In the settings for your repository, click "Secrets" then "New repository secret". Name the secret "NS_TOKEN" and
#    paste in your Platform token. If you do not have a Platform token, or wish to create a new one for GitHub, visit
#    NowSecure Platform and go to "Profile & Preferences" then create a token labelled "GitHub".
#
# 2. Follow the annotated workflow below and make any necessary modifications then save the workflow to your repository
#    and review the "Security" tab once the action has run.

name: "NowSecure"

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  nowsecure:
    name: NowSecure
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build your application
        run: ./gradlew assembleDebug              # Update this to build your Android or iOS application

      - name: Run NowSecure
        uses: nowsecure/nowsecure-action@3b439db31b6dce857b09f5222fd13ffc3159ad26
        with:
          token: ${{ secrets.NS_TOKEN }}
          app_file: app-debug.apk                 # Update this to a path to your .ipa or .apk
          group_id: {{ groupId }}                 # Update this to your desired Platform group ID

      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: NowSecure.sarif
Function 
Import:
https://https://etherscan.io/myapikey_logs?apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K
   ?chainid=1
   &module=account
   &action=addresstokenbalance
 import &address=0x1563F4EaD498EA931bb2CD2DbC3Ae2b8b516FBde
   &page=1
   &offset=100
   &apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K

const chains = [42161, 8453, 10, 534352, 81457]

for (const chain of chains) {

  // endpoint accepts one chain at a time, loop for all your chains
  const balance = fetch(`httpshttps://etherscan.io/myapikey_logs?apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K
     chainid=${chain}
     &module=account
     &action=balance
     &address=0x1563F4EaD498EA931bb2CD2DbC3Ae2b8b516FBde
     &tag=latest&apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K
     
}
import https://github.com/Wesley-tec2/remix-desktop-insiders/blob/main/ADvt2
import 
https://https://etherscan.io/myapikey_logs?apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K?chainid=1 &module=stats &action=tokensupply &contractaddress=0x1563F4EaD498EA931bb2CD2DbC3Ae2b8b516FBde &apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K
function interactWithContract(address contractAddress) public {
    // Function logic here
}
/**
 *Submitted for verification at Etherscan.io on 2025
*/

/**

Deploying ADvt.//
Import 
https://github.com/users/Wesley-tec2/projects/1/views/1

Import https://github.com/Wesley-tec2/remix-desktop-insiders/tree/main
Commit hash: //
Repository://Import 
https://github.com/users/Wesley-tec2/projects/1/views/1

Import https://github.com/Wesley-tec2/remix-desktop-insiders/tree/main
Issues: https://github.com/

Licenses
@openzeppelin/contracts: (MIT) https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE
darknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE

*/



contract Initializable {

  
  bool private initialized;

  
  bool private initializing;

  
  modifier initializer() {
    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");

    bool isTopLevelCall = !initializing;
    if (isTopLevelCall) {
      initializing = true;
      initialized = true;
    }

    _;

    if (isTopLevelCall) {
      initializing = false;
    }
  }

  
  function isConstructor() private view returns (bool) {
    
    
    
    
    
    address self = address(this);
    uint256 cs;
    assembly { cs := extcodesize(self) }
    return cs == 0;
  }

  
  uint256[50] private ______gap;
}

contract Context is Initializable {
    
    
    constructor () internal { }
    

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; 
        return msg.data;
    }
}

contract Ownable is Initializable, Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    function initialize(address sender) public initializer {
        _owner = sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    uint256[50] private ______gap;
}

contract Proxy {
  
  function () payable external {
    _fallback();
  }

  
  function _implementation() internal view returns (address);

  
  function _delegate(address implementation) internal {
    assembly {
      
      
      
      calldatacopy(0, 0, calldatasize)

      
      
      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)

      
      returndatacopy(0, 0, returndatasize)

      switch result
      
      case 0 { revert(0, returndatasize) }
      default { return(0, returndatasize) }
    }
  }

  
  function _willFallback() internal {
  }

  
  function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }
}

library OpenZeppelinUpgradesAddress {
    
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        
        
        
        
        
        
        
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

contract BaseUpgradeabilityProxy is Proxy {
  
  event Upgraded(address indexed implementation);

  
  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

  
  function _implementation() internal view returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      impl := sload(slot)
    }
  }

  
  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

  
  function _setImplementation(address newImplementation) internal {
    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {
      sstore(slot, newImplementation)
    }
  }
}

contract UpgradeabilityProxy is BaseUpgradeabilityProxy {
  
  constructor(address _logic, bytes memory _data) public payable {
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }  
}

contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {
  
  event AdminChanged(address previousAdmin, address newAdmin);

  

  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

  
  modifier ifAdmin() {
    if (msg.sender == _admin()) {
      _;
    } else {
      _fallback();
    }
  }

  
  function admin() external ifAdmin returns (address) {
    return _admin();
  }

  
  function implementation() external ifAdmin returns (address) {
    return _implementation();
  }

  
  function changeAdmin(address newAdmin) external ifAdmin {
    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");
    emit AdminChanged(_admin(), newAdmin);
    _setAdmin(newAdmin);
  }

  
  function upgradeTo(address newImplementation) external ifAdmin {
    _upgradeTo(newImplementation);
  }

  
  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {
    _upgradeTo(newImplementation);
    (bool success,) = newImplementation.delegatecall(data);
    require(success);
  }

  
  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    assembly {
      adm := sload(slot)
    }
  }

  
  function _setAdmin(address newAdmin) internal {
    bytes32 slot = ADMIN_SLOT;

    assembly {
      sstore(slot, newAdmin)
    }
  }

  
  function _willFallback() internal {
    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");
    super._willFallback();
  }
}

contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {
  
  function initialize(address _logic, bytes memory _data) public payable {
    require(_implementation() == address(0));
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }  
}

contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {
  
  function initialize(address _logic, address _admin, bytes memory _data) public payable {
    require(_implementation() == address(0));
    InitializableUpgradeabilityProxy.initialize(_logic, _data);
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
}

interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        
        require(b > 0, errorMessage);
        uint256 c = a / b;
        

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

contract ERC20 is Initializable, Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
    }

    uint256[50] private ______gap;
}

contract ERC20Detailed is Initializable, IERC20 {
    string private _name;addethm 
    string private _symbol;ADvt
    uint8 private _decimals;18

    
    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {
        _name = name;addethm 
        _symbol = symbol;ADvt 
        _decimals = decimals;18
    }

    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    uint256[50] private ______gap;
}

contract Claimable is Initializable, Ownable {
    address public pendingOwner;

    function initialize(address _nextOwner) public initializer {
        Ownable.initialize(_nextOwner);
    }

    modifier onlyPendingOwner() {
        require(
            _msgSender() == pendingOwner,
            "Claimable: caller is not the pending owner"
        );
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(
            newOwner != owner() && newOwner != pendingOwner,
            "Claimable: invalid new owner"
        );
        pendingOwner = newOwner;
    }

    function claimOwnership() public onlyPendingOwner {
        _transferOwnership(pendingOwner);
        delete pendingOwner;
    }
}

library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        
        
        
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        
        assembly { codehash := extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }

    
    function toPayable(address account) internal pure returns (address payable) {
        return address(uint160(account));
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call.value(amount)("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
}

library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        
        
        
        
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        
        

        
        
        
        
        
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { 
            
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract CanReclaimTokens is Claimable {
    using SafeERC20 for ERC20;

    mapping(address => bool) private recoverableTokensBlacklist;

    function initialize(address _nextOwner) public initializer {
        Claimable.initialize(_nextOwner);
    }

    function blacklistRecoverableToken(address _token) public onlyOwner {
        recoverableTokensBlacklist[_token] = true;
    }

    
    
    function recoverTokens(address _token) external onlyOwner {
        require(
            !recoverableTokensBlacklist[_token],
            "CanReclaimTokens: token is not recoverable"
        );

        if (_token == address(0x0)) {
            msg.sender.transfer(address(this).balance);
        } else {
            ERC20(_token).safeTransfer(
                msg.sender,
                ERC20(_token).balanceOf(address(this))
            );
        }
    }
}

contract ERC20WithRate is Initializable, Ownable, ERC20 {
    using SafeMath for uint256;

    uint256 public constant _rateScale = 1e18;
    uint256 internal _rate;

    event LogRateChanged(uint256 indexed _rate);

    
    function initialize(address _nextOwner, uint256 _initialRate)
        public
        initializer
    {
        Ownable.initialize(_nextOwner);
        _setRate(_initialRate);
    }

    function setExchangeRate(uint256 _nextRate) public onlyOwner {
        _setRate(_nextRate);
    }

    function exchangeRateCurrent() public view returns (uint256) {
        require(_rate != 0, "ERC20WithRate: rate has not been initialized");
        return _rate;
    }

    function _setRate(uint256 _nextRate) internal {
        require(_nextRate > 0, "ERC20WithRate: rate must be greater than zero");
        _rate = _nextRate;
    }

    function balanceOfUnderlying(address _account)
        public
        view
        returns (uint256)
    {
        return toUnderlying(balanceOf(_account));
    }

    function toUnderlying(uint256 _amount) public view returns (uint256) {
        return _amount.mul(_rate).div(_rateScale);
    }

    function fromUnderlying(uint256 _amountUnderlying)
        public
        view
        returns (uint256)
    {
        return _amountUnderlying.mul(_rateScale).div(_rate);
    }
}

contract ERC20WithPermit is Initializable, ERC20, ERC20Detailed {
    using SafeMath for uint256;

    mapping(address => uint256) public nonces;

    
    
    string public version;

    
    bytes32 public DOMAIN_SEPARATOR;
    
    
    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;

    function initialize(
        uint256 _chainId,
        string memory _version,
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) public initializer {
        ERC20Detailed.initialize(_name, _symbol, _decimals);
        version = _version;
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(
                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                ),
                keccak256(bytes(name())),
                keccak256(bytes(version)),
                _chainId,
                address(this)
            )
        );
    }

    
    function permit(
        address holder,
        address spender,
        uint256 nonce,
        uint256 expiry,
        bool allowed,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(
                    abi.encode(
                        PERMIT_TYPEHASH,
                        holder,
                        spender,
                        nonce,
                        expiry,
                        allowed
                    )
                )
            )
        );

        require(holder != address(0), "ERC20WithRate: address must not be 0x0");
        require(
            holder == ecrecover(digest, v, r, s),
            "ERC20WithRate: invalid signature"
        );
        require(
            expiry == 0 || now <= expiry,
            "ERC20WithRate: permit has expired"
        );
        require(nonce == nonces[holder]++, "ERC20WithRate: invalid nonce");
        uint256 amount = allowed ? uint256(-1) : 0;
        _approve(holder, spender, amount);
    }
}

contract RenERC20LogicV1 is
    Initializable,
    ERC20,
    ERC20Detailed,
    ERC20WithRate,
    ERC20WithPermit,
    Claimable,
    CanReclaimTokens
{
    
    function initialize(
        uint256 _chainId,
        address _nextOwner,
        uint256 _initialRate,
        string memory _version,
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) public initializer {
        ERC20Detailed.initialize(_name, _symbol, _decimals);
        ERC20WithRate.initialize(_nextOwner, _initialRate);
        ERC20WithPermit.initialize(
            _chainId,
            _version,
            _name,
            _symbol,
            _decimals
        );
        Claimable.initialize(_nextOwner);
        CanReclaimTokens.initialize(_nextOwner);
    }

    
    
    function mint(address _to, uint256 _amount) public onlyOwner {
        _mint(_to, _amount);
    }

    
    
    function burn(address _from, uint256 _amount) public onlyOwner {
        _burn(_from, _amount);
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        
        
        
        require(
            recipient != address(this),
            "RenERC20: can't transfer to token address"
        );
        return super.transfer(recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount)
        public
        returns (bool)
    {
        
        
        require(
            recipient != address(this),
            "RenERC20: can't transfer to token address"
        );
        return super.transferFrom(sender, recipient, amount);
    }
}

contract ADvt is InitializableAdminUpgradeabilityProxy {}

contract ADvt is InitializableAdminUpgradeabilityProxy {}

contract ADvt is InitializableAdminUpgradeabilityProxy {}
[dependent: import:
https://github.com/Wesley-tec2/remix-desktop-insiders/blob/main/ADvt2]
const chains = [42161, 8453, 10, 534352, 81457]

for (const chain of chains) {

  // endpoint accepts one chain at a time, loop for all your chains
  const balance = fetch(`https://api.etherscan.io/v2/api?
     chainid=${chain}
     &module=account
     &action=balance
     &address=0x1563F4EaD498EA931bb2CD2DbC3Ae2b8b516FBde
     &tag=latest&apikey=E4XQS66QJYPBM6ZPIUU3EH9B37NZB5XG7K`)
     
}
ETHERSCAN_API_KEY=VZFDUWB3YGQ1YCDKTCU1D6DDSS
BSCSCAN_API_KEY=ZM8ACMJB67C2IXKKBF8URFUNSY
SNOWSCAN_API_KEY=ATJQERBKV1CI3GVKNSE3Q7RGEJ
ARBISCAN_API_KEY=B6SVGA7K3YBJEQ69AFKJF4YHVX
OPTIMISM_API_KEY=66N5FRNV1ZD4I87S7MAHCJVXFJ

ETHERSCAN_API_URL=https://api.etherscan.io/api
BSCSCAN_API_KEY=https://api.bscscan.com/api
SNOWSCAN_API_KEY=https://api.snowscan.xyz/api
ARBISCAN_API_KEY=https://api.arbiscan.io/api
OPTIMISM_API_KEY=https://api-optimistic.etherscan.io/api
{ // Optional: not present if no errors/warnings/infos were encountered "errors": [ { // Optional: Location within the source file. "sourceLocation": { "file": "sourceFile.sol", "start": 0, "end": 100 }, // Optional: Further locations (e.g. places of conflicting declarations) "secondarySourceLocations": [ { "file": "sourceFile.sol", "start": 64, "end": 92, "message": "Other declaration is here:" } ], // Mandatory: Error type, such as "TypeError", "InternalCompilerError", "Exception", etc. // See below for complete list of types. "type": "TypeError", // Mandatory: Component where the error originated, such as "general" etc. "component": "general", // Mandatory ("error", "warning" or "info", but please note that this may be extended in the future) "severity": "error", // Optional: unique code for the cause of the error "errorCode": "3141", // Mandatory "message": "Invalid keyword", // Optional: the message formatted with source location "formattedMessage": "sourceFile.sol:100: Invalid keyword" } ], // This contains the file-level outputs. // It can be limited/filtered by the outputSelection settings. "sources": { "sourceFile.sol": { // Identifier of the source (used in source maps) "id": 1, // The AST object "ast": {} } }, // This contains the contract-level outputs. // It can be limited/filtered by the outputSelection settings. "contracts": { "sourceFile.sol": { // If the language used has no contract names, this field should equal to an empty string. "ContractName": { // The Ethereum Contract ABI. If empty, it is represented as an empty array. // See https://docs.soliditylang.org/en/develop/abi-spec.html "abi": [], // See the Metadata Output documentation (serialised JSON string) "metadata": "{/* ... */}", // User documentation (natspec) "userdoc": {}, // Developer documentation (natspec) "devdoc": {}, // Intermediate representation before optimization (string) "ir": "", // AST of intermediate representation before optimization "irAst": {/* ... */}, // Intermediate representation after optimization (string) "irOptimized": "", // AST of intermediate representation after optimization "irOptimizedAst": {/* ... */}, // See the Storage Layout documentation. "storageLayout": {"storage": [/* ... */], "types": {/* ... */} }, // See the Storage Layout documentation. "transientStorageLayout": {"storage": [/* ... */], "types": {/* ... */} }, // EVM-related outputs "evm": { // Assembly (string) "assembly": "", // Old-style assembly (object) "legacyAssembly": {}, // Bytecode and related details. "bytecode": { // Debugging data at the level of functions. "functionDebugData": { // Now follows a set of functions including compiler-internal and // user-defined function. The set does not have to be complete. "@mint_13": { // Internal name of the function "entryPoint": 128, // Byte offset into the bytecode where the function starts (optional) "id": 13, // AST ID of the function definition or null for compiler-internal functions (optional) "parameterSlots": 2, // Number of EVM stack slots for the function parameters (optional) "returnSlots": 1 // Number of EVM stack slots for the return values (optional) } }, // The bytecode as a hex string. "object": "00fe", // Opcodes list (string) "opcodes": "", // The source mapping as a string. See the source mapping definition. "sourceMap": "", // Array of sources generated by the compiler. Currently only // contains a single Yul file. "generatedSources": [{ // Yul AST "ast": {/* ... */}, // Source file in its text form (may contain comments) "contents":"{ function abi_decode(start, end) -> data { data := calldataload(start) } }", // Source file ID, used for source references, same "namespace" as the Solidity source files "id": 2, "language": "Yul", "name": "#utility.yul" }], // If given, this is an unlinked object. "linkReferences": { "libraryFile.sol": { // Byte offsets into the bytecode. // Linking replaces the 20 bytes located there. "Library1": [ { "start": 0, "length": 20 }, { "start": 200, "length": 20 } ] } } }, "deployedBytecode": { /* ..., */ // The same layout as above. "immutableReferences": { // There are two references to the immutable with AST ID 3, both 32 bytes long. One is // at bytecode offset 42, the other at bytecode offset 80. "3": [{ "start": 42, "length": 32 }, { "start": 80, "length": 32 }] } }, // The list of function hashes "methodIdentifiers": { "delegate(address)": "5c19a95c" }, // Function gas estimates "gasEstimates": { "creation": { "codeDepositCost": "420000", "executionCost": "infinite", "totalCost": "infinite" }, "external": { "delegate(address)": "25000" }, "internal": { "heavyLifting()": "infinite" } } } } } } }{ "sources": {/* ... */}, "settings": { "optimizer": {/* ... */}, "evmVersion": "<VERSION>" } }
{ // Required: Source code language. Currently supported are "Solidity", "Yul", "SolidityAST" (experimental), "EVMAssembly" (experimental). "language": "Solidity", // Required "sources": { // The keys here are the "global" names of the source files, // imports can use other files via remappings (see below). "myFile.sol": { // Optional: keccak256 hash of the source file // It is used to verify the retrieved content if imported via URLs. "keccak256": "0x123...", // Required (unless "content" is used, see below): URL(s) to the source file. // URL(s) should be imported in this order and the result checked against the // keccak256 hash (if available). If the hash doesn't match or none of the // URL(s) result in success, an error should be raised. // Using the commandline interface only filesystem paths are supported. // With the JavaScript interface the URL will be passed to the user-supplied // read callback, so any URL supported by the callback can be used. "urls": [ "bzzr://56ab...", "ipfs://Qma...", "/tmp/path/to/file.sol" // If files are used, their directories should be added to the command-line via // `--allow-paths <path>`. ] }, "settable": { // Optional: keccak256 hash of the source file "keccak256": "0x234...", // Required (unless "urls" is used): literal contents of the source file "content": "contract settable is owned { uint256 private x = 0; function set(uint256 _x) public { if (msg.sender == owner) x = _x; } }" }, "myFile.sol_json.ast": { // If language is set to "SolidityAST", an AST needs to be supplied under the "ast" key // and there can be only one source file present. // The format is the same as used by the `ast` output. // Note that importing ASTs is experimental and in particular that: // - importing invalid ASTs can produce undefined results and // - no proper error reporting is available on invalid ASTs. // Furthermore, note that the AST import only consumes the fields of the AST as // produced by the compiler in "stopAfter": "parsing" mode and then re-performs // analysis, so any analysis-based annotations of the AST are ignored upon import. "ast": { ... } }, "myFile_evm.json": { // If language is set to "EVMAssembly", an EVM Assembly JSON object needs to be supplied // under the "assemblyJson" key and there can be only one source file present. // The format is the same as used by the `evm.legacyAssembly` output or `--asm-json` // output on the command line. // Note that importing EVM assembly is experimental. "assemblyJson": { ".code": [ ... ], ".data": { ... }, // optional "sourceList": [ ... ] // optional (if no `source` node was defined in any `.code` object) } } }, // Optional "settings": { // Optional: Stop compilation after the given stage. Currently only "parsing" is valid here "stopAfter": "parsing", // Optional: List of remappings "remappings": [ ":g=/dir" ], // Optional: Optimizer settings "optimizer": { // Turn on the optimizer. Optional. Default: false. // NOTE: The state of the optimizer is fully determined by the 'details' dict and this setting // only affects its defaults - when enabled, all components default to being enabled. // The opposite is not true - there are several components that always default to being // enabled an can only be explicitly disabled via 'details'. // WARNING: Before version 0.8.6 omitting this setting was not equivalent to setting // it to false and would result in all components being disabled instead. // WARNING: Enabling optimizations for EVMAssembly input is allowed but not necessary under normal // circumstances. It forces the opcode-based optimizer to run again and can produce bytecode that // is not reproducible from metadata. "enabled": true, // Optimize for how many times you intend to run the code. Optional. Default: 200. // Lower values will optimize more for initial deployment cost, higher // values will optimize more for high-frequency usage. "runs": 200, // State of all optimizer components. Optional. // Default values are determined by whether the optimizer is enabled or not. // Note that the 'enabled' setting only affects the defaults here and has no effect when // all values are provided explicitly. "details": { // Peephole optimizer (opcode-based). Optional. Default: true. // Default for EVMAssembly input: false when optimization is not enabled. // NOTE: Always runs (even with optimization disabled) except for EVMAssembly input or when explicitly turned off here. "peephole": true, // Inliner (opcode-based). Optional. Default: true when optimization is enabled. "inliner": false, // Unused JUMPDEST remover (opcode-based). Optional. Default: true. // Default for EVMAssembly input: false when optimization is not enabled. // NOTE: Always runs (even with optimization disabled) except for EVMAssembly input or when explicitly turned off here. "jumpdestRemover": true, // Literal reordering (codegen-based). Optional. Default: true when optimization is enabled. // Moves literals to the right of commutative binary operators during code generation, helping exploit associativity. "orderLiterals": false, // Block deduplicator (opcode-based). Optional. Default: true when optimization is enabled. // Unifies assembly code blocks that share content. "deduplicate": false, // Common subexpression elimination (opcode-based). Optional. Default: true when optimization is enabled. // This is the most complicated step but can also provide the largest gain. "cse": false, // Constant optimizer (opcode-based). Optional. Default: true when optimization is enabled. // Tries to find better representations of literal numbers and strings, that satisfy the // size/cost trade-off determined by the 'runs' setting. "constantOptimizer": false, // Unchecked loop increment (codegen-based). Optional. Default: true. // Use unchecked arithmetic when incrementing the counter of 'for' loops under certain circumstances. // NOTE: Always runs (even with optimization disabled) unless explicitly turned off here. "simpleCounterForLoopUncheckedIncrement": true, // Yul optimizer. Optional. Default: true when optimization is enabled. // Used to optimize the IR produced by the Yul IR-based pipeline as well as inline assembly // and utility Yul code generated by the compiler. // NOTE: Before Solidity 0.6.0 the default was false. "yul": false, // Tuning options for the Yul optimizer. Optional. "yulDetails": { // Improve allocation of stack slots for variables, can free up stack slots early. // Optional. Default: true if Yul optimizer is enabled. "stackAllocation": true, // Optimization step sequence. // The general form of the value is "<main sequence>:<cleanup sequence>". // The setting is optional and when omitted, default values are used for both sequences. // If the value does not contain the ':' delimiter, it is interpreted as the main // sequence and the default is used for the cleanup sequence. // To make one of the sequences empty, the delimiter must be present at the first or last position. // In particular if the whole value consists only of the delimiter, both sequences are empty. // Note that there are several hard-coded steps that always run, even when both sequences are empty. // For more information see "The Optimizer > Selecting Optimizations". "optimizerSteps": "dhfoDgvulfnTUtnIf..." } } }, // Version of the EVM to compile for (optional). // Affects type checking and code generation. Can be homestead, // tangerineWhistle, spuriousDragon, byzantium, constantinople, // petersburg, istanbul, berlin, london, paris, shanghai, cancun, prague (default) or osaka (experimental). "evmVersion": "prague", // EVM Object Format version to compile for (optional, experimental). // Currently the only valid value is 1. If not specified, legacy non-EOF bytecode will be generated. "eofVersion": null, // Optional: Change compilation pipeline to go through the Yul intermediate representation. // This is false by default. "viaIR": true, // Optional: Debugging settings "debug": { // How to treat revert (and require) reason strings. Settings are // "default", "strip", "debug" and "verboseDebug". // "default" does not inject compiler-generated revert strings and keeps user-supplied ones. // "strip" removes all revert strings (if possible, i.e. if literals are used) keeping side-effects // "debug" injects strings for compiler-generated internal reverts, implemented for ABI encoders V1 and V2 for now. // "verboseDebug" even appends further information to user-supplied revert strings (not yet implemented) "revertStrings": "default", // Optional: How much extra debug information to include in comments in the produced EVM // assembly and Yul code. Available components are: // - `location`: Annotations of the form `@src <index>:<start>:<end>` indicating the // location of the corresponding element in the original Solidity file, where: // - `<index>` is the file index matching the `@use-src` annotation, // - `<start>` is the index of the first byte at that location, // - `<end>` is the index of the first byte after that location. // - `snippet`: A single-line code snippet from the location indicated by `@src`. // The snippet is quoted and follows the corresponding `@src` annotation. // - `*`: Wildcard value that can be used to request everything. "debugInfo": ["location", "snippet"] }, // Metadata settings (optional) "metadata": { // The CBOR metadata is appended at the end of the bytecode by default. // Setting this to false omits the metadata from the runtime and deploy time code. "appendCBOR": true, // Use only literal content and not URLs (false by default) "useLiteralContent": true, // Use the given hash method for the metadata hash that is appended to the bytecode. // The metadata hash can be removed from the bytecode via option "none". // The other options are "ipfs" and "bzzr1". // If the option is omitted, "ipfs" is used by default. "bytecodeHash": "ipfs" }, // Addresses of the libraries. If not all libraries are given here, // it can result in unlinked objects whose output data is different. "libraries": { // The top level key is the name of the source file where the library is used. // If remappings are used, this source file should match the global path // after remappings were applied. // If this key is an empty string, that refers to a global level. "myFile.sol": { "MyLib": "0x123123..." } }, // The following can be used to select desired outputs based // on file and contract names. // If this field is omitted, then the compiler loads and does type checking, // but will not generate any outputs apart from errors. // The first level key is the file name and the second level key is the contract name. // An empty contract name is used for outputs that are not tied to a contract // but to the whole source file like the AST. // A star as contract name refers to all contracts in the file. // Similarly, a star as a file name matches all files. // To select all outputs the compiler can possibly generate, with the exclusion of // Yul intermediate representation outputs, use // "outputSelection: { "*": { "*": [ "*" ], "": [ "*" ] } }" // but note that this might slow down the compilation process needlessly. // // The available output types are as follows: // // File level (needs empty string as contract name): // ast - AST of all source files // // Contract level (needs the contract name or "*"): // abi - ABI // devdoc - Developer documentation (natspec) // userdoc - User documentation (natspec) // metadata - Metadata // ir - Yul intermediate representation of the code before optimization // irAst - AST of Yul intermediate representation of the code before optimization // irOptimized - Intermediate representation after optimization // irOptimizedAst - AST of intermediate representation after optimization // storageLayout - Slots, offsets and types of the contract's state variables in storage. // transientStorageLayout - Slots, offsets and types of the contract's state variables in transient storage. // evm.assembly - New assembly format // evm.legacyAssembly - Old-style assembly format in JSON // evm.bytecode.functionDebugData - Debugging information at function level // evm.bytecode.object - Bytecode object // evm.bytecode.opcodes - Opcodes list // evm.bytecode.sourceMap - Source mapping (useful for debugging) // evm.bytecode.linkReferences - Link references (if unlinked object) // evm.bytecode.generatedSources - Sources generated by the compiler // evm.deployedBytecode* - Deployed bytecode (has all the options that evm.bytecode has) // evm.deployedBytecode.immutableReferences - Map from AST ids to bytecode ranges that reference immutables // evm.methodIdentifiers - The list of function hashes // evm.gasEstimates - Function gas estimates // // Note that using `evm`, `evm.bytecode`, etc. will select every // target part of that output. Additionally, `*` can be used as a wildcard to request everything. // "outputSelection": { "*": { "*": [ "metadata", "evm.bytecode" // Enable the metadata and bytecode outputs of every single contract. , "evm.bytecode.sourceMap" // Enable the source map output of every single contract. ], "": [ "ast" // Enable the AST output of every single file. ] }, // Enable the abi and opcodes output of MyContract defined in file def. "def": { "MyContract": [ "abi", "evm.bytecode.opcodes" ] } }, // The modelChecker object is experimental and subject to changes. "modelChecker": { // Chose which contracts should be analyzed as the deployed one. "contracts": { "source1.sol": ["contract1"], "source2.sol": ["contract2", "contract3"] }, // Choose how division and modulo operations should be encoded. // When using `false` they are replaced by multiplication with slack // variables. This is the default. // Using `true` here is recommended if you are using the CHC engine // and not using Spacer as the Horn solver (using Eldarica, for example). // See the Formal Verification section for a more detailed explanation of this option. "divModNoSlacks": false, // Choose which model checker engine to use: all (default), bmc, chc, none. "engine": "chc", // Choose whether external calls should be considered trusted in case the // code of the called function is available at compile-time. // For details see the SMTChecker section. "extCalls": "trusted", // Choose which types of invariants should be reported to the user: contract, reentrancy. "invariants": ["contract", "reentrancy"], // Choose whether to output all proved targets. The default is `false`. "showProvedSafe": true, // Choose whether to output all unproved targets. The default is `false`. "showUnproved": true, // Choose whether to output all unsupported language features. The default is `false`. "showUnsupported": true, // Choose which solvers should be used, if available. // See the Formal Verification section for the solvers description. "solvers": ["cvc5", "smtlib2", "z3"], // Choose which targets should be checked: constantCondition, // underflow, overflow, divByZero, balance, assert, popEmptyArray, outOfBounds. // If the option is not given all targets are checked by default, // except underflow/overflow for Solidity >=0.8.7. // See the Formal Verification section for the targets description. "targets": ["underflow", "overflow", "assert"], // Timeout for each SMT query in milliseconds. // If this option is not given, the SMTChecker will use a deterministic // resource limit by default. // A given timeout of 0 means no resource/time restrictions for any query. "timeout": 20000 } } } 
import {IERC20AntiWhale} from "../interfaces/services/IERC20AntiWhale.sol";

